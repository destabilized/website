<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sophomore week 16</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="../blog-posts.css">
</head>
<body>

<main>
    <div class="container">
        <div class="yap">
            <h1>soph week 5/12 - 5/16</h1>
            <p>wanted to further simplify my code, even though it was already pretty simplified. also added a few things.</p>

            <h2> directional movement changes</h2>
            <p>previously, my code looked like this. </p>
            
            <pre><code class="cpp">
void forward() {
    digitalWrite(MOTOR_A1, HIGH); digitalWrite(MOTOR_B1, HIGH); digitalWrite(MOTOR_A2, LOW); digitalWrite(MOTOR_B2, LOW);
}

void right() {
    digitalWrite(MOTOR_A1, HIGH); digitalWrite(MOTOR_B1, LOW); digitalWrite(MOTOR_A2, LOW); digitalWrite(MOTOR_B2, LOW);
}

void sstop() {
    digitalWrite(MOTOR_A1, LOW); digitalWrite(MOTOR_B1, LOW); digitalWrite(MOTOR_A2, LOW); digitalWrite(MOTOR_B2, LOW);
}

void left() {
    digitalWrite(MOTOR_A1, LOW); digitalWrite(MOTOR_B1, HIGH); digitalWrite(MOTOR_A2, LOW); digitalWrite(MOTOR_B2, LOW);
}
            </code></pre>

            <p> while there is nothing wrong with this, it was quite cluttered with all the digitalwrites, so i decided to simplify it.</p>
            <p>using a function to control the motors, i was able to set a value (high or low) to each motor without having to continuously write “digitalwrite(motor____, high/low).</p>
            
            <pre><code class="cpp">
void controlMotors(int a1, int a2, int b1, int b2) {
    digitalWrite(MOTOR_A1, a1);
    digitalWrite(MOTOR_A2, a2);
    digitalWrite(MOTOR_B1, b1);
    digitalWrite(MOTOR_B2, b2);
}
            </code></pre>
            <p> with this, i could just set low or high for each state</p>

            <pre><code class="cpp">
void forward() {
    controlMotors(LOW, HIGH, LOW, HIGH);
}

void right() {
    controlMotors(HIGH, LOW, LOW, HIGH);
}

void sstop() {
    controlMotors(LOW, LOW, LOW, LOW);
}

void left() {
    controlMotors(LOW, HIGH, HIGH, LOW);
}

void backwards() {
    controlMotors(HIGH, LOW, HIGH, LOW);
}
</code></pre>
            <p> in addition, i got rid of my old star function and “startR” function as the right button for some reason didn’t work. (probably cause i wired it wrong on my pcb).</p>
            
            <h2> button changes </h2>
            <p>since the right button was always “on” for some reason, i decided that it wasn’t necessary, and just removed it. also, since my code for the buttons was all over the place, i decided to consolidate it into a single function.</p>
            
            <pre><code class="cpp">
void buttonhandling() {
    if (digitalRead(BUTTON_L) == LOW) {
        can_start = false;
        Serial.println("startL");
        startL();
    }
}
</code></pre>
            <h6>this keeps the same idea and attack pattern of the button, but consolidated.</h6>

            <h2> sensor changes</h2>
            <p> with my old code, when the sensors got activated, the motors moved backwards for a set amount of time. however, it sometimes wouldn’t be enough time, and would end up moving forward too early / turning too early.</p>
            <p>to fix this, we used a while loop and waited an extra second before starting the turn. in addition, more functions were created to further neaten up the code.</p>
            <p> old:</p>

            <pre><code class="cpp">

void sensorhandling() {
    // NC pin. HIGH PUSHED, LOW NOT PUSHED 
    if (digitalRead(SEN_L) == HIGH && digitalRead(SEN_R) == HIGH) {
        backwards();
    }
    else if (digitalRead(SEN_R) == LOW && digitalRead(SEN_L) == HIGH) {
        backwards();
        delay(300);
        right();
        Serial.println("turn right");
        delay(200);
    }

    else if (digitalRead(SEN_L) == LOW && digitalRead(SEN_R) == HIGH) {
        backwards();
        delay(300);
        left();
        Serial.println("turn left");
        delay(200);
    }

    else {
        forward();
        Serial.println("forward");
        delay(500);
    }
}

</code></pre>
            <p> new:</p>

            <pre><code class="cpp">

void sensorhandling() {
    // NC pin. HIGH PUSHED, LOW NOT PUSHED 
    if (digitalRead(SEN_L) == HIGH && digitalRead(SEN_R) == HIGH) {
        backwards();
    }
    else if (digitalRead(SEN_R) == LOW && digitalRead(SEN_L) == HIGH) {
        while(digitalRead(SEN_R) == LOW && digitalRead(SEN_L) == HIGH) {
            backwards();
        }
        delay(1000);
        turnRandom(left);
    }
    

    else if (digitalRead(SEN_L) == LOW && digitalRead(SEN_R) == HIGH) {
        while (digitalRead(SEN_L) == LOW && digitalRead(SEN_R) == HIGH) {
            backwards()
        }
            delay(1000);
            turnRandom(right);
    }

    else {
        forward();
    }
}

</code></pre>
            <p> with all of these coding changes, my setup and loop was simplified drastically, now looking like this: </p>
            
            <pre><code class="cpp">
void setup() {
    Serial.begin(9600);
    pinMode(MOTOR_A1, OUTPUT); pinMode(MOTOR_A2, OUTPUT); pinMode(MOTOR_B1, OUTPUT); pinMode(MOTOR_B2, OUTPUT); 
    pinMode(SEN_L, INPUT_PULLUP); pinMode(SEN_R, INPUT_PULLUP);
    pinMode(BUTTON_L, INPUT_PULLUP); pinMode(BUTTON_R, INPUT_PULLUP);
}

void loop() {
    if (can_start) {
        buttonhandling();
    }

    if (!can_start) {
        sensorhandling();
    }
}
</code></pre>
            <h2>testing shenanigans</h2>
            <p>we finally decided to get our sumobot assembled and i could finally test my code just to find some problems while testing. we encountered quite a bit of problems that we had to fix.</p>
            <p>however, if anyone saw my pcb schematic that i made for the sumobot, you may have noticed that i don’t have a common ground.</p>
            
            <h2> pcb problem</h2>
            <p> well, we all didn’t notice this until we started to test the sumobot where we saw that the sumobot only got power when the lever roller switches weren’t pressed down for some reason. despite this, it worked to some degree for some reason (probably using a digital pin on the metromini as ground?)</p>
            <p> after some re-looking on the pcb document, we noticed this problem. however, rather than re-milling a pcb, we decided to just make a new trace for ground. </p>
            
            <img src="../../../img/soph/16/fixed_ground.jpeg">
            <p> with this fixed, we started testing again.</p>
            
            <h2> minor setback</h2>
            <p> one of the main issues that we wanted to address was the lack of turning by the sumobot. while this was a quick fix of changing the delays to allow the backwards(); function to further back up, i accidentally broke one of the two sumobots.</p>
            
            <div class="two-imgs">
                <img src="../../../static/img/soph/16/broken.jpeg">
                <img src="../../../static/img/soph/16/broken2.jpeg">
            </div> 
            
            <p>for some reason, i just forgot to react or protect the bot in case it fell of the table, and it ended up falling off the table.</p>
            <p>while this was easily fixed by reprinting the base and re-cutting the acrylic piece, it was a minor setback, and i started testing code on the second sumobot that miles made.</p>
            
            <h2> testing problems cont.</h2>
            <p>right away, we noticed that one of the major problems was that the robot when crossing the white line (as the lever rollers can’t detect color but rather when it isn’t pressed), it was unable to bring itself back up.</p>
            
            <video controls>
                <source src="../../../static/vids/soph/16/problem.mp4" type="video/mp4">
            </video>
            <p>me and miles spent quite a while debugging possible fixes to this problem, some of which included: - increasing the amount of times moving backwards off the edge - implementing a “bunnyhop” mechanism where it “jumps”, detaching the switches from the edge. - adding a ramp to the sensors so it wouldn’t get caught on the edge.</p>
            <p>while the first two mechanisms didn’t work, miles eventually noticed that due to the “90°” angle with the rollers, it wouldn’t get back up as it was stuck in a perpendicular angle from the edge and the roller. to fix this, he suggested making a ramp to put onto the sensors to prevent it from getting jammed.</p>
            
            <img src="../../static/img/soph/16/improv.jpeg">
            <h6>cardboard ramps to prevent jamming on the edge</h6>
            <p>we decided to just use cardboard for a quick fix. combined with some hot glue, this ended up working amazingly.</p>
            
            <video controls>
                <source src="../../../static/vids/soph/16/fixed.mp4" type="video/mp4">
            </video>
            <p>finally, we wanted to not have a set amount of turning delay, as it led to predictable movements and the sumobot staying on one side of the arena.</p>

            <h2>turning fixes + problems</h2>
            <p>originally, i was going to use a random function to generate a random number for the delay value, something like this: </p>

            <pre><code class="cpp">
long x;

void setup() {
    Serial.begin(9600);
}

void loop() {
    randomSeed(micros());
    x =  random(500, 1501);
    Serial.println(x);
    delay(500);
}
</code></pre>
            <p>however, while setting this up in the sumobot i realized that every time the sumobot was run, the same values were showing up.</p>
            
            <img src="../../../static/img/soph/16/turning_problems.jpeg">
            <h6>startL indicates that it has been rerun, and you can see that the same values show up.</h6>
            <p>this was because i had the seed where the random numbers would come from in the setup, where it would only change if it was re-uploaded. to fix this, i moved it to when the button gets pressed, which led to randomness every time like i wanted.</p>
            
            <img src="../../../static/img/soph/16/turning_fix.jpeg">
            <h6> different numbers... wow!</h6>
            <p>with all of this, i believe our sumobot is done. potentially gotta fix the problems where it gets stuck for a bit (if possible), but that’s all.</p>
            
            <video controls>
                <source src="../../../static/vids/soph/16/turning.mp4" type="video/mp4">
            </video>
            <h2> sumobot results</h2>
            <p>the orange bot (the one that miles claimed) got second, losing to tims and benji with their extremely fast, suicide bot.</p>
            <p>while we are given an extra week to revamp and improve our bots (as a few didn’t work as intended), we likely won’t be continuing our bot, marking the end of this project..</p>
            
            <p> long post. thanks for reading it if you did.</p>
            <video controls>
                <source src="../../../static/vids/soph/16/funny.mp4" type="video/mp4">
            </video>
            <div class="navigation">
                <a href="../../blog.html" class="buttons">← back to all blogs </a>
                <a href="week_15.html" class="buttons"> last week post →</a>
            </div>
        </div>
    </div>
</main>


</body>
</html>
